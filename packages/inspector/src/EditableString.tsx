import { createElement, Fragment } from "preact";
import { useState, useRef, useEffect } from "preact/hooks";

export default function EditableString({
  color,
  value,
  onChange,
  expanded,
}: {
  color: string;
  value: string;
  onChange: (value: string) => void;
  expanded: boolean;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedValue, setEditedValue] = useState(value);
  const measureWidthRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement | null>(null);

  const TagName = expanded ? "textarea" : "input";

  useEffect(() => {
    if (expanded) return;

    const measureWidth = measureWidthRef.current;
    const input = inputRef.current;

    if (!measureWidth) return;
    if (!input) return;

    measureWidth.style.display = "inline";
    const rect = measureWidth.getBoundingClientRect();
    measureWidth.style.display = "none";

    input.style.width = rect.width + "px";
  }, [editedValue, value]);

  const currentValue = isEditing ? editedValue : value;

  return (
    <>
      <span
        style={{ display: "none" }}
        ref={measureWidthRef}
        className="measure-width"
      >
        {currentValue}
      </span>
      <TagName
        // @ts-ignore
        ref={inputRef}
        style={{ color, font: "inherit", maxWidth: "200px" }}
        value={currentValue}
        onFocus={() => {
          setEditedValue(value);
          setIsEditing(true);
        }}
        onChange={(
          event: createElement.JSX.TargetedEvent<
            HTMLInputElement | HTMLTextAreaElement
          >
        ) => {
          if (!expanded && measureWidthRef.current) {
            event.currentTarget.style.width =
              measureWidthRef.current.getBoundingClientRect().width + "px";
          }

          setEditedValue(event.currentTarget.value);
          onChange(event.currentTarget.value);
        }}
        onBlur={() => {
          setIsEditing(false);
        }}
        onKeyDown={(
          event: createElement.JSX.TargetedEvent<
            HTMLInputElement | HTMLTextAreaElement,
            KeyboardEvent
          >
        ) => {
          if (String(Number(currentValue)) !== currentValue) return;

          let delta = 0;
          if (event.key === "ArrowDown") {
            delta = -1;
          } else if (event.key === "ArrowUp") {
            delta = 1;
          }

          if (event.shiftKey && event.altKey) {
            delta *= Math.PI / 16;
          } else if (event.shiftKey) {
            delta *= 10;
          } else if (event.altKey) {
            delta *= 0.1;
          }

          const newValue = String(Number(currentValue) + delta);
          setEditedValue(newValue);
          onChange(newValue);
        }}
      />
    </>
  );
}
